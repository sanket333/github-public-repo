{"ast":null,"code":"import { getUserAgent } from 'universal-user-agent';\nimport { request } from '@octokit/request';\nimport { createOAuthAppAuth } from '@octokit/auth-oauth-app';\nimport { Deprecation } from 'deprecation';\nimport { githubAppJwt } from 'universal-github-app-jwt';\nimport LRU from 'lru-cache';\nimport { requiresBasicAuth } from '@octokit/auth-oauth-user';\nexport { createOAuthUserAuth } from '@octokit/auth-oauth-user';\nasync function getAppAuthentication(_ref) {\n  let {\n    appId,\n    privateKey,\n    timeDifference\n  } = _ref;\n  try {\n    const appAuthentication = await githubAppJwt({\n      id: +appId,\n      privateKey,\n      now: timeDifference && Math.floor(Date.now() / 1000) + timeDifference\n    });\n    return {\n      type: \"app\",\n      token: appAuthentication.token,\n      appId: appAuthentication.appId,\n      expiresAt: new Date(appAuthentication.expiration * 1000).toISOString()\n    };\n  } catch (error) {\n    if (privateKey === \"-----BEGIN RSA PRIVATE KEY-----\") {\n      throw new Error(\"The 'privateKey` option contains only the first line '-----BEGIN RSA PRIVATE KEY-----'. If you are setting it using a `.env` file, make sure it is set on a single line with newlines replaced by '\\n'\");\n    } else {\n      throw error;\n    }\n  }\n}\n\n// https://github.com/isaacs/node-lru-cache#readme\nfunction getCache() {\n  return new LRU({\n    // cache max. 15000 tokens, that will use less than 10mb memory\n    max: 15000,\n    // Cache for 1 minute less than GitHub expiry\n    maxAge: 1000 * 60 * 59\n  });\n}\nasync function get(cache, options) {\n  const cacheKey = optionsToCacheKey(options);\n  const result = await cache.get(cacheKey);\n  if (!result) {\n    return;\n  }\n  const [token, createdAt, expiresAt, repositorySelection, permissionsString, singleFileName] = result.split(\"|\");\n  const permissions = options.permissions || permissionsString.split(/,/).reduce((permissions, string) => {\n    if (/!$/.test(string)) {\n      permissions[string.slice(0, -1)] = \"write\";\n    } else {\n      permissions[string] = \"read\";\n    }\n    return permissions;\n  }, {});\n  return {\n    token,\n    createdAt,\n    expiresAt,\n    permissions,\n    repositoryIds: options.repositoryIds,\n    repositoryNames: options.repositoryNames,\n    singleFileName,\n    repositorySelection: repositorySelection\n  };\n}\nasync function set(cache, options, data) {\n  const key = optionsToCacheKey(options);\n  const permissionsString = options.permissions ? \"\" : Object.keys(data.permissions).map(name => `${name}${data.permissions[name] === \"write\" ? \"!\" : \"\"}`).join(\",\");\n  const value = [data.token, data.createdAt, data.expiresAt, data.repositorySelection, permissionsString, data.singleFileName].join(\"|\");\n  await cache.set(key, value);\n}\nfunction optionsToCacheKey(_ref2) {\n  let {\n    installationId,\n    permissions = {},\n    repositoryIds = [],\n    repositoryNames = []\n  } = _ref2;\n  const permissionsString = Object.keys(permissions).sort().map(name => permissions[name] === \"read\" ? name : `${name}!`).join(\",\");\n  const repositoryIdsString = repositoryIds.sort().join(\",\");\n  const repositoryNamesString = repositoryNames.join(\",\");\n  return [installationId, repositoryIdsString, repositoryNamesString, permissionsString].filter(Boolean).join(\"|\");\n}\nfunction toTokenAuthentication(_ref3) {\n  let {\n    installationId,\n    token,\n    createdAt,\n    expiresAt,\n    repositorySelection,\n    permissions,\n    repositoryIds,\n    repositoryNames,\n    singleFileName\n  } = _ref3;\n  return Object.assign({\n    type: \"token\",\n    tokenType: \"installation\",\n    token,\n    installationId,\n    permissions,\n    createdAt,\n    expiresAt,\n    repositorySelection\n  }, repositoryIds ? {\n    repositoryIds\n  } : null, repositoryNames ? {\n    repositoryNames\n  } : null, singleFileName ? {\n    singleFileName\n  } : null);\n}\nasync function getInstallationAuthentication(state, options, customRequest) {\n  const installationId = Number(options.installationId || state.installationId);\n  if (!installationId) {\n    throw new Error(\"[@octokit/auth-app] installationId option is required for installation authentication.\");\n  }\n  if (options.factory) {\n    const {\n      type,\n      factory,\n      oauthApp,\n      ...factoryAuthOptions\n    } = {\n      ...state,\n      ...options\n    };\n    // @ts-expect-error if `options.factory` is set, the return type for `auth()` should be `Promise<ReturnType<options.factory>>`\n    return factory(factoryAuthOptions);\n  }\n  const optionsWithInstallationTokenFromState = Object.assign({\n    installationId\n  }, options);\n  if (!options.refresh) {\n    const result = await get(state.cache, optionsWithInstallationTokenFromState);\n    if (result) {\n      const {\n        token,\n        createdAt,\n        expiresAt,\n        permissions,\n        repositoryIds,\n        repositoryNames,\n        singleFileName,\n        repositorySelection\n      } = result;\n      return toTokenAuthentication({\n        installationId,\n        token,\n        createdAt,\n        expiresAt,\n        permissions,\n        repositorySelection,\n        repositoryIds,\n        repositoryNames,\n        singleFileName\n      });\n    }\n  }\n  const appAuthentication = await getAppAuthentication(state);\n  const request = customRequest || state.request;\n  const {\n    data: {\n      token,\n      expires_at: expiresAt,\n      repositories,\n      permissions: permissionsOptional,\n      repository_selection: repositorySelectionOptional,\n      single_file: singleFileName\n    }\n  } = await request(\"POST /app/installations/{installation_id}/access_tokens\", {\n    installation_id: installationId,\n    repository_ids: options.repositoryIds,\n    repositories: options.repositoryNames,\n    permissions: options.permissions,\n    mediaType: {\n      previews: [\"machine-man\"]\n    },\n    headers: {\n      authorization: `bearer ${appAuthentication.token}`\n    }\n  });\n  /* istanbul ignore next - permissions are optional per OpenAPI spec, but we think that is incorrect */\n  const permissions = permissionsOptional || {};\n  /* istanbul ignore next - repositorySelection are optional per OpenAPI spec, but we think that is incorrect */\n  const repositorySelection = repositorySelectionOptional || \"all\";\n  const repositoryIds = repositories ? repositories.map(r => r.id) : void 0;\n  const repositoryNames = repositories ? repositories.map(repo => repo.name) : void 0;\n  const createdAt = new Date().toISOString();\n  await set(state.cache, optionsWithInstallationTokenFromState, {\n    token,\n    createdAt,\n    expiresAt,\n    repositorySelection,\n    permissions,\n    repositoryIds,\n    repositoryNames,\n    singleFileName\n  });\n  return toTokenAuthentication({\n    installationId,\n    token,\n    createdAt,\n    expiresAt,\n    repositorySelection,\n    permissions,\n    repositoryIds,\n    repositoryNames,\n    singleFileName\n  });\n}\nasync function auth(state, authOptions) {\n  switch (authOptions.type) {\n    case \"app\":\n      return getAppAuthentication(state);\n    // @ts-expect-error \"oauth\" is not supperted in types\n    case \"oauth\":\n      state.log.warn(\n      // @ts-expect-error `log.warn()` expects string\n      new Deprecation(`[@octokit/auth-app] {type: \"oauth\"} is deprecated. Use {type: \"oauth-app\"} instead`));\n    case \"oauth-app\":\n      return state.oauthApp({\n        type: \"oauth-app\"\n      });\n    case \"installation\":\n      return getInstallationAuthentication(state, {\n        ...authOptions,\n        type: \"installation\"\n      });\n    case \"oauth-user\":\n      // @ts-expect-error TODO: infer correct auth options type based on type. authOptions should be typed as \"WebFlowAuthOptions | OAuthAppDeviceFlowAuthOptions | GitHubAppDeviceFlowAuthOptions\"\n      return state.oauthApp(authOptions);\n    default:\n      // @ts-expect-error type is \"never\" at this point\n      throw new Error(`Invalid auth type: ${authOptions.type}`);\n  }\n}\nconst PATHS = [\"/app\", \"/app/hook/config\", \"/app/hook/deliveries\", \"/app/hook/deliveries/{delivery_id}\", \"/app/hook/deliveries/{delivery_id}/attempts\", \"/app/installations\", \"/app/installations/{installation_id}\", \"/app/installations/{installation_id}/access_tokens\", \"/app/installations/{installation_id}/suspended\", \"/marketplace_listing/accounts/{account_id}\", \"/marketplace_listing/plan\", \"/marketplace_listing/plans\", \"/marketplace_listing/plans/{plan_id}/accounts\", \"/marketplace_listing/stubbed/accounts/{account_id}\", \"/marketplace_listing/stubbed/plan\", \"/marketplace_listing/stubbed/plans\", \"/marketplace_listing/stubbed/plans/{plan_id}/accounts\", \"/orgs/{org}/installation\", \"/repos/{owner}/{repo}/installation\", \"/users/{username}/installation\"];\n// CREDIT: Simon Grondin (https://github.com/SGrondin)\n// https://github.com/octokit/plugin-throttling.js/blob/45c5d7f13b8af448a9dbca468d9c9150a73b3948/lib/route-matcher.js\nfunction routeMatcher(paths) {\n  // EXAMPLE. For the following paths:\n  /* [\n      \"/orgs/{org}/invitations\",\n      \"/repos/{owner}/{repo}/collaborators/{username}\"\n  ] */\n  const regexes = paths.map(p => p.split(\"/\").map(c => c.startsWith(\"{\") ? \"(?:.+?)\" : c).join(\"/\"));\n  // 'regexes' would contain:\n  /* [\n      '/orgs/(?:.+?)/invitations',\n      '/repos/(?:.+?)/(?:.+?)/collaborators/(?:.+?)'\n  ] */\n  const regex = `^(?:${regexes.map(r => `(?:${r})`).join(\"|\")})[^/]*$`;\n  // 'regex' would contain:\n  /*\n    ^(?:(?:\\/orgs\\/(?:.+?)\\/invitations)|(?:\\/repos\\/(?:.+?)\\/(?:.+?)\\/collaborators\\/(?:.+?)))[^\\/]*$\n       It may look scary, but paste it into https://www.debuggex.com/\n    and it will make a lot more sense!\n  */\n  return new RegExp(regex, \"i\");\n}\nconst REGEX = routeMatcher(PATHS);\nfunction requiresAppAuth(url) {\n  return !!url && REGEX.test(url);\n}\nconst FIVE_SECONDS_IN_MS = 5 * 1000;\nfunction isNotTimeSkewError(error) {\n  return !(error.message.match(/'Expiration time' claim \\('exp'\\) must be a numeric value representing the future time at which the assertion expires/) || error.message.match(/'Issued at' claim \\('iat'\\) must be an Integer representing the time that the assertion was issued/));\n}\nasync function hook(state, request, route, parameters) {\n  const endpoint = request.endpoint.merge(route, parameters);\n  const url = endpoint.url;\n  // Do not intercept request to retrieve a new token\n  if (/\\/login\\/oauth\\/access_token$/.test(url)) {\n    return request(endpoint);\n  }\n  if (requiresAppAuth(url.replace(request.endpoint.DEFAULTS.baseUrl, \"\"))) {\n    const {\n      token\n    } = await getAppAuthentication(state);\n    endpoint.headers.authorization = `bearer ${token}`;\n    let response;\n    try {\n      response = await request(endpoint);\n    } catch (error) {\n      // If there's an issue with the expiration, regenerate the token and try again.\n      // Otherwise rethrow the error for upstream handling.\n      if (isNotTimeSkewError(error)) {\n        throw error;\n      }\n      // If the date header is missing, we can't correct the system time skew.\n      // Throw the error to be handled upstream.\n      if (typeof error.response.headers.date === \"undefined\") {\n        throw error;\n      }\n      const diff = Math.floor((Date.parse(error.response.headers.date) - Date.parse(new Date().toString())) / 1000);\n      state.log.warn(error.message);\n      state.log.warn(`[@octokit/auth-app] GitHub API time and system time are different by ${diff} seconds. Retrying request with the difference accounted for.`);\n      const {\n        token\n      } = await getAppAuthentication({\n        ...state,\n        timeDifference: diff\n      });\n      endpoint.headers.authorization = `bearer ${token}`;\n      return request(endpoint);\n    }\n    return response;\n  }\n  if (requiresBasicAuth(url)) {\n    const authentication = await state.oauthApp({\n      type: \"oauth-app\"\n    });\n    endpoint.headers.authorization = authentication.headers.authorization;\n    return request(endpoint);\n  }\n  const {\n    token,\n    createdAt\n  } = await getInstallationAuthentication(state,\n  // @ts-expect-error TBD\n  {}, request);\n  endpoint.headers.authorization = `token ${token}`;\n  return sendRequestWithRetries(state, request, endpoint, createdAt);\n}\n/**\n * Newly created tokens might not be accessible immediately after creation.\n * In case of a 401 response, we retry with an exponential delay until more\n * than five seconds pass since the creation of the token.\n *\n * @see https://github.com/octokit/auth-app.js/issues/65\n */\nasync function sendRequestWithRetries(state, request, options, createdAt) {\n  let retries = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  const timeSinceTokenCreationInMs = +new Date() - +new Date(createdAt);\n  try {\n    return await request(options);\n  } catch (error) {\n    if (error.status !== 401) {\n      throw error;\n    }\n    if (timeSinceTokenCreationInMs >= FIVE_SECONDS_IN_MS) {\n      if (retries > 0) {\n        error.message = `After ${retries} retries within ${timeSinceTokenCreationInMs / 1000}s of creating the installation access token, the response remains 401. At this point, the cause may be an authentication problem or a system outage. Please check https://www.githubstatus.com for status information`;\n      }\n      throw error;\n    }\n    ++retries;\n    const awaitTime = retries * 1000;\n    state.log.warn(`[@octokit/auth-app] Retrying after 401 response to account for token replication delay (retry: ${retries}, wait: ${awaitTime / 1000}s)`);\n    await new Promise(resolve => setTimeout(resolve, awaitTime));\n    return sendRequestWithRetries(state, request, options, createdAt, retries);\n  }\n}\nconst VERSION = \"4.0.9\";\nfunction createAppAuth(options) {\n  if (!options.appId) {\n    throw new Error(\"[@octokit/auth-app] appId option is required\");\n  }\n  if (!Number.isFinite(+options.appId)) {\n    throw new Error(\"[@octokit/auth-app] appId option must be a number or numeric string\");\n  }\n  if (!options.privateKey) {\n    throw new Error(\"[@octokit/auth-app] privateKey option is required\");\n  }\n  if (\"installationId\" in options && !options.installationId) {\n    throw new Error(\"[@octokit/auth-app] installationId is set to a falsy value\");\n  }\n  const log = Object.assign({\n    warn: console.warn.bind(console)\n  }, options.log);\n  const request$1 = options.request || request.defaults({\n    headers: {\n      \"user-agent\": `octokit-auth-app.js/${VERSION} ${getUserAgent()}`\n    }\n  });\n  const state = Object.assign({\n    request: request$1,\n    cache: getCache()\n  }, options, options.installationId ? {\n    installationId: Number(options.installationId)\n  } : {}, {\n    log,\n    oauthApp: createOAuthAppAuth({\n      clientType: \"github-app\",\n      clientId: options.clientId || \"\",\n      clientSecret: options.clientSecret || \"\",\n      request: request$1\n    })\n  });\n  // @ts-expect-error not worth the extra code to appease TS\n  return Object.assign(auth.bind(null, state), {\n    hook: hook.bind(null, state)\n  });\n}\nexport { createAppAuth };","map":{"version":3,"names":["getAppAuthentication","_ref","appId","privateKey","timeDifference","appAuthentication","githubAppJwt","id","now","Math","floor","Date","type","token","expiresAt","expiration","toISOString","error","Error","getCache","LRU","max","maxAge","get","cache","options","cacheKey","optionsToCacheKey","result","createdAt","repositorySelection","permissionsString","singleFileName","split","permissions","reduce","string","test","slice","repositoryIds","repositoryNames","set","data","key","Object","keys","map","name","join","value","_ref2","installationId","sort","repositoryIdsString","repositoryNamesString","filter","Boolean","toTokenAuthentication","_ref3","assign","tokenType","getInstallationAuthentication","state","customRequest","Number","factory","oauthApp","factoryAuthOptions","optionsWithInstallationTokenFromState","refresh","request","expires_at","repositories","permissionsOptional","repository_selection","repositorySelectionOptional","single_file","installation_id","repository_ids","mediaType","previews","headers","authorization","r","repo","auth","authOptions","log","warn","Deprecation","PATHS","routeMatcher","paths","regexes","p","c","startsWith","regex","RegExp","REGEX","requiresAppAuth","url","FIVE_SECONDS_IN_MS","isNotTimeSkewError","message","match","hook","route","parameters","endpoint","merge","replace","DEFAULTS","baseUrl","response","date","diff","parse","toString","requiresBasicAuth","authentication","sendRequestWithRetries","retries","arguments","length","undefined","timeSinceTokenCreationInMs","status","awaitTime","Promise","resolve","setTimeout","VERSION","createAppAuth","isFinite","console","bind","request$1","defaults","getUserAgent","createOAuthAppAuth","clientType","clientId","clientSecret"],"sources":["/home/lenovo/Documents/personal/redux_cart/gihub-repo/node_modules/@octokit/auth-app/dist-src/get-app-authentication.js","/home/lenovo/Documents/personal/redux_cart/gihub-repo/node_modules/@octokit/auth-app/dist-src/cache.js","/home/lenovo/Documents/personal/redux_cart/gihub-repo/node_modules/@octokit/auth-app/dist-src/to-token-authentication.js","/home/lenovo/Documents/personal/redux_cart/gihub-repo/node_modules/@octokit/auth-app/dist-src/get-installation-authentication.js","/home/lenovo/Documents/personal/redux_cart/gihub-repo/node_modules/@octokit/auth-app/dist-src/auth.js","/home/lenovo/Documents/personal/redux_cart/gihub-repo/node_modules/@octokit/auth-app/dist-src/requires-app-auth.js","/home/lenovo/Documents/personal/redux_cart/gihub-repo/node_modules/@octokit/auth-app/dist-src/hook.js","/home/lenovo/Documents/personal/redux_cart/gihub-repo/node_modules/@octokit/auth-app/dist-src/version.js","/home/lenovo/Documents/personal/redux_cart/gihub-repo/node_modules/@octokit/auth-app/dist-src/index.js"],"sourcesContent":["import { githubAppJwt } from \"universal-github-app-jwt\";\nexport async function getAppAuthentication({ appId, privateKey, timeDifference, }) {\n    try {\n        const appAuthentication = await githubAppJwt({\n            id: +appId,\n            privateKey,\n            now: timeDifference && Math.floor(Date.now() / 1000) + timeDifference,\n        });\n        return {\n            type: \"app\",\n            token: appAuthentication.token,\n            appId: appAuthentication.appId,\n            expiresAt: new Date(appAuthentication.expiration * 1000).toISOString(),\n        };\n    }\n    catch (error) {\n        if (privateKey === \"-----BEGIN RSA PRIVATE KEY-----\") {\n            throw new Error(\"The 'privateKey` option contains only the first line '-----BEGIN RSA PRIVATE KEY-----'. If you are setting it using a `.env` file, make sure it is set on a single line with newlines replaced by '\\n'\");\n        }\n        else {\n            throw error;\n        }\n    }\n}\n","// https://github.com/isaacs/node-lru-cache#readme\nimport LRU from \"lru-cache\";\nexport function getCache() {\n    return new LRU({\n        // cache max. 15000 tokens, that will use less than 10mb memory\n        max: 15000,\n        // Cache for 1 minute less than GitHub expiry\n        maxAge: 1000 * 60 * 59,\n    });\n}\nexport async function get(cache, options) {\n    const cacheKey = optionsToCacheKey(options);\n    const result = await cache.get(cacheKey);\n    if (!result) {\n        return;\n    }\n    const [token, createdAt, expiresAt, repositorySelection, permissionsString, singleFileName,] = result.split(\"|\");\n    const permissions = options.permissions ||\n        permissionsString.split(/,/).reduce((permissions, string) => {\n            if (/!$/.test(string)) {\n                permissions[string.slice(0, -1)] = \"write\";\n            }\n            else {\n                permissions[string] = \"read\";\n            }\n            return permissions;\n        }, {});\n    return {\n        token,\n        createdAt,\n        expiresAt,\n        permissions,\n        repositoryIds: options.repositoryIds,\n        repositoryNames: options.repositoryNames,\n        singleFileName,\n        repositorySelection: repositorySelection,\n    };\n}\nexport async function set(cache, options, data) {\n    const key = optionsToCacheKey(options);\n    const permissionsString = options.permissions\n        ? \"\"\n        : Object.keys(data.permissions)\n            .map((name) => `${name}${data.permissions[name] === \"write\" ? \"!\" : \"\"}`)\n            .join(\",\");\n    const value = [\n        data.token,\n        data.createdAt,\n        data.expiresAt,\n        data.repositorySelection,\n        permissionsString,\n        data.singleFileName,\n    ].join(\"|\");\n    await cache.set(key, value);\n}\nfunction optionsToCacheKey({ installationId, permissions = {}, repositoryIds = [], repositoryNames = [], }) {\n    const permissionsString = Object.keys(permissions)\n        .sort()\n        .map((name) => (permissions[name] === \"read\" ? name : `${name}!`))\n        .join(\",\");\n    const repositoryIdsString = repositoryIds.sort().join(\",\");\n    const repositoryNamesString = repositoryNames.join(\",\");\n    return [\n        installationId,\n        repositoryIdsString,\n        repositoryNamesString,\n        permissionsString,\n    ]\n        .filter(Boolean)\n        .join(\"|\");\n}\n","export function toTokenAuthentication({ installationId, token, createdAt, expiresAt, repositorySelection, permissions, repositoryIds, repositoryNames, singleFileName, }) {\n    return Object.assign({\n        type: \"token\",\n        tokenType: \"installation\",\n        token,\n        installationId,\n        permissions,\n        createdAt,\n        expiresAt,\n        repositorySelection,\n    }, repositoryIds ? { repositoryIds } : null, repositoryNames ? { repositoryNames } : null, singleFileName ? { singleFileName } : null);\n}\n","import { get, set } from \"./cache\";\nimport { getAppAuthentication } from \"./get-app-authentication\";\nimport { toTokenAuthentication } from \"./to-token-authentication\";\nexport async function getInstallationAuthentication(state, options, customRequest) {\n    const installationId = Number(options.installationId || state.installationId);\n    if (!installationId) {\n        throw new Error(\"[@octokit/auth-app] installationId option is required for installation authentication.\");\n    }\n    if (options.factory) {\n        const { type, factory, oauthApp, ...factoryAuthOptions } = {\n            ...state,\n            ...options,\n        };\n        // @ts-expect-error if `options.factory` is set, the return type for `auth()` should be `Promise<ReturnType<options.factory>>`\n        return factory(factoryAuthOptions);\n    }\n    const optionsWithInstallationTokenFromState = Object.assign({ installationId }, options);\n    if (!options.refresh) {\n        const result = await get(state.cache, optionsWithInstallationTokenFromState);\n        if (result) {\n            const { token, createdAt, expiresAt, permissions, repositoryIds, repositoryNames, singleFileName, repositorySelection, } = result;\n            return toTokenAuthentication({\n                installationId,\n                token,\n                createdAt,\n                expiresAt,\n                permissions,\n                repositorySelection,\n                repositoryIds,\n                repositoryNames,\n                singleFileName,\n            });\n        }\n    }\n    const appAuthentication = await getAppAuthentication(state);\n    const request = customRequest || state.request;\n    const { data: { token, expires_at: expiresAt, repositories, permissions: permissionsOptional, repository_selection: repositorySelectionOptional, single_file: singleFileName, }, } = await request(\"POST /app/installations/{installation_id}/access_tokens\", {\n        installation_id: installationId,\n        repository_ids: options.repositoryIds,\n        repositories: options.repositoryNames,\n        permissions: options.permissions,\n        mediaType: {\n            previews: [\"machine-man\"],\n        },\n        headers: {\n            authorization: `bearer ${appAuthentication.token}`,\n        },\n    });\n    /* istanbul ignore next - permissions are optional per OpenAPI spec, but we think that is incorrect */\n    const permissions = permissionsOptional || {};\n    /* istanbul ignore next - repositorySelection are optional per OpenAPI spec, but we think that is incorrect */\n    const repositorySelection = repositorySelectionOptional || \"all\";\n    const repositoryIds = repositories\n        ? repositories.map((r) => r.id)\n        : void 0;\n    const repositoryNames = repositories\n        ? repositories.map((repo) => repo.name)\n        : void 0;\n    const createdAt = new Date().toISOString();\n    await set(state.cache, optionsWithInstallationTokenFromState, {\n        token,\n        createdAt,\n        expiresAt,\n        repositorySelection,\n        permissions,\n        repositoryIds,\n        repositoryNames,\n        singleFileName,\n    });\n    return toTokenAuthentication({\n        installationId,\n        token,\n        createdAt,\n        expiresAt,\n        repositorySelection,\n        permissions,\n        repositoryIds,\n        repositoryNames,\n        singleFileName,\n    });\n}\n","import { Deprecation } from \"deprecation\";\nimport { getAppAuthentication } from \"./get-app-authentication\";\nimport { getInstallationAuthentication } from \"./get-installation-authentication\";\nexport async function auth(state, authOptions) {\n    switch (authOptions.type) {\n        case \"app\":\n            return getAppAuthentication(state);\n        // @ts-expect-error \"oauth\" is not supperted in types\n        case \"oauth\":\n            state.log.warn(\n            // @ts-expect-error `log.warn()` expects string\n            new Deprecation(`[@octokit/auth-app] {type: \"oauth\"} is deprecated. Use {type: \"oauth-app\"} instead`));\n        case \"oauth-app\":\n            return state.oauthApp({ type: \"oauth-app\" });\n        case \"installation\":\n            authOptions;\n            return getInstallationAuthentication(state, {\n                ...authOptions,\n                type: \"installation\",\n            });\n        case \"oauth-user\":\n            // @ts-expect-error TODO: infer correct auth options type based on type. authOptions should be typed as \"WebFlowAuthOptions | OAuthAppDeviceFlowAuthOptions | GitHubAppDeviceFlowAuthOptions\"\n            return state.oauthApp(authOptions);\n        default:\n            // @ts-expect-error type is \"never\" at this point\n            throw new Error(`Invalid auth type: ${authOptions.type}`);\n    }\n}\n","const PATHS = [\n    \"/app\",\n    \"/app/hook/config\",\n    \"/app/hook/deliveries\",\n    \"/app/hook/deliveries/{delivery_id}\",\n    \"/app/hook/deliveries/{delivery_id}/attempts\",\n    \"/app/installations\",\n    \"/app/installations/{installation_id}\",\n    \"/app/installations/{installation_id}/access_tokens\",\n    \"/app/installations/{installation_id}/suspended\",\n    \"/marketplace_listing/accounts/{account_id}\",\n    \"/marketplace_listing/plan\",\n    \"/marketplace_listing/plans\",\n    \"/marketplace_listing/plans/{plan_id}/accounts\",\n    \"/marketplace_listing/stubbed/accounts/{account_id}\",\n    \"/marketplace_listing/stubbed/plan\",\n    \"/marketplace_listing/stubbed/plans\",\n    \"/marketplace_listing/stubbed/plans/{plan_id}/accounts\",\n    \"/orgs/{org}/installation\",\n    \"/repos/{owner}/{repo}/installation\",\n    \"/users/{username}/installation\",\n];\n// CREDIT: Simon Grondin (https://github.com/SGrondin)\n// https://github.com/octokit/plugin-throttling.js/blob/45c5d7f13b8af448a9dbca468d9c9150a73b3948/lib/route-matcher.js\nfunction routeMatcher(paths) {\n    // EXAMPLE. For the following paths:\n    /* [\n        \"/orgs/{org}/invitations\",\n        \"/repos/{owner}/{repo}/collaborators/{username}\"\n    ] */\n    const regexes = paths.map((p) => p\n        .split(\"/\")\n        .map((c) => (c.startsWith(\"{\") ? \"(?:.+?)\" : c))\n        .join(\"/\"));\n    // 'regexes' would contain:\n    /* [\n        '/orgs/(?:.+?)/invitations',\n        '/repos/(?:.+?)/(?:.+?)/collaborators/(?:.+?)'\n    ] */\n    const regex = `^(?:${regexes.map((r) => `(?:${r})`).join(\"|\")})[^/]*$`;\n    // 'regex' would contain:\n    /*\n      ^(?:(?:\\/orgs\\/(?:.+?)\\/invitations)|(?:\\/repos\\/(?:.+?)\\/(?:.+?)\\/collaborators\\/(?:.+?)))[^\\/]*$\n  \n      It may look scary, but paste it into https://www.debuggex.com/\n      and it will make a lot more sense!\n    */\n    return new RegExp(regex, \"i\");\n}\nconst REGEX = routeMatcher(PATHS);\nexport function requiresAppAuth(url) {\n    return !!url && REGEX.test(url);\n}\n","import { requiresBasicAuth } from \"@octokit/auth-oauth-user\";\nimport { getAppAuthentication } from \"./get-app-authentication\";\nimport { getInstallationAuthentication } from \"./get-installation-authentication\";\nimport { requiresAppAuth } from \"./requires-app-auth\";\nconst FIVE_SECONDS_IN_MS = 5 * 1000;\nfunction isNotTimeSkewError(error) {\n    return !(error.message.match(/'Expiration time' claim \\('exp'\\) must be a numeric value representing the future time at which the assertion expires/) ||\n        error.message.match(/'Issued at' claim \\('iat'\\) must be an Integer representing the time that the assertion was issued/));\n}\nexport async function hook(state, request, route, parameters) {\n    const endpoint = request.endpoint.merge(route, parameters);\n    const url = endpoint.url;\n    // Do not intercept request to retrieve a new token\n    if (/\\/login\\/oauth\\/access_token$/.test(url)) {\n        return request(endpoint);\n    }\n    if (requiresAppAuth(url.replace(request.endpoint.DEFAULTS.baseUrl, \"\"))) {\n        const { token } = await getAppAuthentication(state);\n        endpoint.headers.authorization = `bearer ${token}`;\n        let response;\n        try {\n            response = await request(endpoint);\n        }\n        catch (error) {\n            // If there's an issue with the expiration, regenerate the token and try again.\n            // Otherwise rethrow the error for upstream handling.\n            if (isNotTimeSkewError(error)) {\n                throw error;\n            }\n            // If the date header is missing, we can't correct the system time skew.\n            // Throw the error to be handled upstream.\n            if (typeof error.response.headers.date === \"undefined\") {\n                throw error;\n            }\n            const diff = Math.floor((Date.parse(error.response.headers.date) -\n                Date.parse(new Date().toString())) /\n                1000);\n            state.log.warn(error.message);\n            state.log.warn(`[@octokit/auth-app] GitHub API time and system time are different by ${diff} seconds. Retrying request with the difference accounted for.`);\n            const { token } = await getAppAuthentication({\n                ...state,\n                timeDifference: diff,\n            });\n            endpoint.headers.authorization = `bearer ${token}`;\n            return request(endpoint);\n        }\n        return response;\n    }\n    if (requiresBasicAuth(url)) {\n        const authentication = await state.oauthApp({ type: \"oauth-app\" });\n        endpoint.headers.authorization = authentication.headers.authorization;\n        return request(endpoint);\n    }\n    const { token, createdAt } = await getInstallationAuthentication(state, \n    // @ts-expect-error TBD\n    {}, request);\n    endpoint.headers.authorization = `token ${token}`;\n    return sendRequestWithRetries(state, request, endpoint, createdAt);\n}\n/**\n * Newly created tokens might not be accessible immediately after creation.\n * In case of a 401 response, we retry with an exponential delay until more\n * than five seconds pass since the creation of the token.\n *\n * @see https://github.com/octokit/auth-app.js/issues/65\n */\nasync function sendRequestWithRetries(state, request, options, createdAt, retries = 0) {\n    const timeSinceTokenCreationInMs = +new Date() - +new Date(createdAt);\n    try {\n        return await request(options);\n    }\n    catch (error) {\n        if (error.status !== 401) {\n            throw error;\n        }\n        if (timeSinceTokenCreationInMs >= FIVE_SECONDS_IN_MS) {\n            if (retries > 0) {\n                error.message = `After ${retries} retries within ${timeSinceTokenCreationInMs / 1000}s of creating the installation access token, the response remains 401. At this point, the cause may be an authentication problem or a system outage. Please check https://www.githubstatus.com for status information`;\n            }\n            throw error;\n        }\n        ++retries;\n        const awaitTime = retries * 1000;\n        state.log.warn(`[@octokit/auth-app] Retrying after 401 response to account for token replication delay (retry: ${retries}, wait: ${awaitTime / 1000}s)`);\n        await new Promise((resolve) => setTimeout(resolve, awaitTime));\n        return sendRequestWithRetries(state, request, options, createdAt, retries);\n    }\n}\n","export const VERSION = \"4.0.9\";\n","import { getUserAgent } from \"universal-user-agent\";\nimport { request as defaultRequest } from \"@octokit/request\";\nimport { createOAuthAppAuth } from \"@octokit/auth-oauth-app\";\nimport { auth } from \"./auth\";\nimport { hook } from \"./hook\";\nimport { getCache } from \"./cache\";\nimport { VERSION } from \"./version\";\nexport { createOAuthUserAuth } from \"@octokit/auth-oauth-user\";\nexport function createAppAuth(options) {\n    if (!options.appId) {\n        throw new Error(\"[@octokit/auth-app] appId option is required\");\n    }\n    if (!Number.isFinite(+options.appId)) {\n        throw new Error(\"[@octokit/auth-app] appId option must be a number or numeric string\");\n    }\n    if (!options.privateKey) {\n        throw new Error(\"[@octokit/auth-app] privateKey option is required\");\n    }\n    if (\"installationId\" in options && !options.installationId) {\n        throw new Error(\"[@octokit/auth-app] installationId is set to a falsy value\");\n    }\n    const log = Object.assign({\n        warn: console.warn.bind(console),\n    }, options.log);\n    const request = options.request ||\n        defaultRequest.defaults({\n            headers: {\n                \"user-agent\": `octokit-auth-app.js/${VERSION} ${getUserAgent()}`,\n            },\n        });\n    const state = Object.assign({\n        request,\n        cache: getCache(),\n    }, options, options.installationId\n        ? { installationId: Number(options.installationId) }\n        : {}, {\n        log,\n        oauthApp: createOAuthAppAuth({\n            clientType: \"github-app\",\n            clientId: options.clientId || \"\",\n            clientSecret: options.clientSecret || \"\",\n            request,\n        }),\n    });\n    // @ts-expect-error not worth the extra code to appease TS\n    return Object.assign(auth.bind(null, state), {\n        hook: hook.bind(null, state),\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}